<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>ìˆ˜ë ¨ì¥ 2: í•œì ê·¸ë¦¬ê¸° (ëª¨ë°”ì¼)</title>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Gaegu:wght@400;700&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">

    <!-- Common Mobile Styles -->
    <link rel="stylesheet" href="common.css">

    <style>
        :root {
            --deep-green: #0F4221;
            --pure-white: #FFFFFF;
            --soft-beige: #E8C78E;
            --dark-brown: #312117;
            --muted-taupe: #625152;
        }

        body {
            background: var(--soft-beige);
            font-family: 'Gaegu', cursive;
            overflow: hidden;
        }

        .mobile-container {
            display: flex;
            flex-direction: column;
        }

        /* ìƒë‹¨ í—¤ë” */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            padding-top: calc(12px + env(safe-area-inset-top, 0));
            background: var(--deep-green);
            color: white;
            z-index: 10;
        }

        .header-title {
            font-size: 20px;
            font-weight: bold;
        }

        .header-btn {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.15);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        /* ìº”ë²„ìŠ¤ ì˜ì—­ */
        .canvas-area {
            flex: 1;
            background: var(--pure-white);
            position: relative;
            overflow: hidden;
            border: 4px solid var(--dark-brown);
            border-radius: 0;
            margin: 8px;
            margin-bottom: 0;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }

        #mainCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        /* í•˜ë‹¨ ë„êµ¬ë°” */
        .bottom-toolbar {
            background: var(--muted-taupe);
            padding: 12px 8px;
            padding-bottom: calc(12px + env(safe-area-inset-bottom, 0));
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* ë„êµ¬ ë²„íŠ¼ í–‰ */
        .tool-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .tool-btn {
            width: 52px;
            height: 52px;
            background: var(--pure-white);
            border-radius: 14px;
            border: 3px solid var(--dark-brown);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 0 var(--dark-brown);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .tool-btn:active {
            transform: translateY(3px);
            box-shadow: none;
        }

        .tool-btn.active {
            background: var(--soft-beige);
            transform: translateY(3px);
            box-shadow: none;
        }

        /* ì˜µì…˜ í–‰ (ìƒ‰ìƒ, êµµê¸°) */
        .option-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 3px solid var(--dark-brown);
            cursor: pointer;
        }

        .color-btn.active {
            box-shadow: 0 0 0 3px var(--pure-white), 0 0 0 6px var(--dark-brown);
        }

        .size-slider {
            width: 120px;
            height: 8px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 4px;
            outline: none;
        }

        .size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--deep-green);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* ìŠ¤í‹°ì»¤ ì„ íƒ íŒ¨ë„ */
        .sticker-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--pure-white);
            border-top: 3px solid var(--dark-brown);
            border-radius: 20px 20px 0 0;
            padding: 16px;
            padding-bottom: calc(16px + env(safe-area-inset-bottom, 0));
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            z-index: 100;
        }

        .sticker-panel.active {
            transform: translateY(0);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .panel-title {
            font-size: 20px;
            font-weight: bold;
            color: var(--dark-brown);
        }

        .panel-close {
            width: 32px;
            height: 32px;
            background: var(--muted-taupe);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 16px;
        }

        .sticker-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
        }

        .sticker-item {
            aspect-ratio: 1;
            background: #f9f9f9;
            border-radius: 12px;
            border: 2px solid #eee;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sticker-item:active {
            background: var(--soft-beige);
        }

        /* ì»¨íŒ ëª¨ë‹¬ */
        .confirm-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .confirm-overlay.active {
            display: flex;
        }

        .confirm-box {
            background: var(--pure-white);
            padding: 24px;
            border-radius: 20px;
            border: 4px solid var(--dark-brown);
            text-align: center;
            width: 280px;
        }

        .confirm-msg {
            font-size: 20px;
            color: var(--dark-brown);
            margin-bottom: 20px;
            font-weight: bold;
        }

        .confirm-btns {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .confirm-btn {
            padding: 12px 24px;
            border-radius: 10px;
            border: none;
            font-family: 'Gaegu', cursive;
            font-size: 18px;
            font-weight: bold;
        }

        .confirm-yes {
            background: #8B0000;
            color: white;
        }

        .confirm-no {
            background: var(--muted-taupe);
            color: white;
        }

        /* ë¶“ ì¢…ë¥˜ */
        .brush-type-row {
            display: flex;
            gap: 6px;
            justify-content: center;
        }

        .brush-type-btn {
            padding: 6px 12px;
            border: 2px solid var(--dark-brown);
            border-radius: 8px;
            background: #f9f9f9;
            font-size: 14px;
            font-weight: bold;
            color: var(--dark-brown);
        }

        .brush-type-btn.active {
            background: var(--deep-green);
            color: white;
        }
    </style>
</head>
<body>
    <div class="mobile-container">
        <!-- ìƒë‹¨ í—¤ë” -->
        <header class="app-header">
            <button id="btn-back" class="header-btn">â†</button>
            <h1 class="header-title">í•œì ì“°ê¸° ìŠ¤íŠœë””ì˜¤</h1>
            <div class="header-actions">
                <button id="btn-undo" class="header-btn">â†©ï¸</button>
                <button id="btn-clear" class="header-btn">ğŸ—‘ï¸</button>
            </div>
        </header>

        <!-- ìº”ë²„ìŠ¤ ì˜ì—­ -->
        <div class="canvas-area">
            <canvas id="mainCanvas"></canvas>
        </div>

        <!-- í•˜ë‹¨ ë„êµ¬ë°” -->
        <div class="bottom-toolbar">
            <!-- ë„êµ¬ ë²„íŠ¼ë“¤ -->
            <div class="tool-row">
                <button class="tool-btn active" data-mode="draw">ğŸ–Œï¸</button>
                <button class="tool-btn" data-mode="sticker">ğŸ»</button>
                <button class="tool-btn" data-mode="pan">ğŸ–ï¸</button>
                <button class="tool-btn" data-mode="eraser">ğŸ§½</button>
            </div>

            <!-- ë¶“ ì¢…ë¥˜ -->
            <div class="brush-type-row" id="brush-types">
                <button class="brush-type-btn active" data-brush="normal">ì—°í•„</button>
                <button class="brush-type-btn" data-brush="calligraphy">ì„œì˜ˆ</button>
                <button class="brush-type-btn" data-brush="glow">í˜•ê´‘</button>
            </div>

            <!-- ìƒ‰ìƒ + êµµê¸° -->
            <div class="option-row">
                <button class="color-btn active" data-color="#000000" style="background:#000000"></button>
                <button class="color-btn" data-color="#312117" style="background:#312117"></button>
                <button class="color-btn" data-color="#8B0000" style="background:#8B0000"></button>
                <button class="color-btn" data-color="#0F4221" style="background:#0F4221"></button>
                <button class="color-btn" data-color="#00008B" style="background:#00008B"></button>
                <button class="color-btn" data-color="#FFD700" style="background:#FFD700"></button>
                <input type="range" class="size-slider" id="sizeSlider" min="2" max="30" value="8">
            </div>
        </div>

        <!-- ìŠ¤í‹°ì»¤ ì„ íƒ íŒ¨ë„ -->
        <div id="sticker-panel" class="sticker-panel">
            <div class="panel-header">
                <span class="panel-title">ì¹­ì°¬ ìŠ¤í‹°ì»¤</span>
                <button id="btn-close-sticker" class="panel-close">âœ•</button>
            </div>
            <div class="sticker-grid" id="sticker-grid">
                <!-- ìŠ¤í‹°ì»¤ë“¤ì´ ë™ì ìœ¼ë¡œ ì¶”ê°€ë¨ -->
            </div>
        </div>

        <!-- ì»¨íŒ ëª¨ë‹¬ -->
        <div id="confirm-overlay" class="confirm-overlay">
            <div class="confirm-box">
                <div class="confirm-msg" id="confirm-msg">ì´ˆê¸°í™”í• ê¹Œìš”?</div>
                <div class="confirm-btns">
                    <button id="confirm-yes" class="confirm-btn confirm-yes">ë„¤</button>
                    <button id="confirm-no" class="confirm-btn confirm-no">ì•„ë‹ˆì˜¤</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ìº”ë²„ìŠ¤ ì„¤ì •
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const bgImg = new Image();
        bgImg.src = '../img/hanja.png';

        // ìƒíƒœ ë³€ìˆ˜
        let bgOpacity = 0.5;
        let zoomLevel = 1.0;
        let panOffset = { x: 0, y: 0 };
        let lastTouchPos = { x: 0, y: 0 };

        let diaryData = { actions: [] };
        let mode = 'draw';
        let brushType = 'normal';
        let isDrawing = false;
        let isPanning = false;
        let activeColor = '#000000';
        let activeSize = 8;
        let currentSticker = 'ğŸ»';
        const storageKey = 'hanjaStage2:mobile';
        let saveTimer = null;

        // DOM ìš”ì†Œ
        const toolBtns = document.querySelectorAll('.tool-btn');
        const colorBtns = document.querySelectorAll('.color-btn');
        const brushTypeBtns = document.querySelectorAll('.brush-type-btn');
        const sizeSlider = document.getElementById('sizeSlider');
        const stickerPanel = document.getElementById('sticker-panel');
        const stickerGrid = document.getElementById('sticker-grid');
        const confirmOverlay = document.getElementById('confirm-overlay');

        // ìŠ¤í‹°ì»¤ ëª©ë¡
        const emojis = ['ğŸ»','âœ…','â­','â¤ï¸','ğŸ‘','ğŸ‰','ğŸ€','âœ¨','ğŸ¥‡','ğŸ”¥','ğŸ’','ğŸŒˆ'];

        // ì´ˆê¸°í™”
        function init() {
            initCanvas();
            initStickers();
            loadState();
            bgImg.onload = render;
            if (bgImg.complete) render();
        }

        function initCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            render();
        }

        function initStickers() {
            stickerGrid.innerHTML = '';
            emojis.forEach(emoji => {
                const item = document.createElement('button');
                item.className = 'sticker-item';
                item.textContent = emoji;
                item.addEventListener('click', () => selectSticker(emoji));
                stickerGrid.appendChild(item);
            });
        }

        // ìƒíƒœ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°
        function scheduleSave() {
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(saveState, 300);
        }

        function saveState() {
            const payload = {
                bgOpacity,
                zoomLevel,
                panOffset,
                activeColor,
                activeSize,
                brushType,
                currentSticker,
                diaryData
            };
            localStorage.setItem(storageKey, JSON.stringify(payload));
        }

        function loadState() {
            try {
                const saved = JSON.parse(localStorage.getItem(storageKey) || 'null');
                if (!saved) return;

                bgOpacity = saved.bgOpacity ?? bgOpacity;
                zoomLevel = saved.zoomLevel ?? zoomLevel;
                panOffset = saved.panOffset ?? panOffset;
                activeColor = saved.activeColor ?? activeColor;
                activeSize = saved.activeSize ?? activeSize;
                brushType = saved.brushType ?? brushType;
                currentSticker = saved.currentSticker ?? currentSticker;
                diaryData = saved.diaryData ?? diaryData;

                sizeSlider.value = activeSize;

                colorBtns.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.color === activeColor);
                });

                brushTypeBtns.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.brush === brushType);
                });

                render();
            } catch (e) {
                console.error('Failed to load state:', e);
            }
        }

        // ë Œë”ë§
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            ctx.translate(canvas.width / 2 + panOffset.x, canvas.height / 2 + panOffset.y);
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);

            // ë°°ê²½ ì´ë¯¸ì§€
            ctx.save();
            ctx.globalAlpha = bgOpacity;
            if (bgImg.complete && bgImg.naturalWidth > 0) {
                const scale = Math.min(canvas.width / bgImg.width, canvas.height / bgImg.height) * 0.9;
                const x = (canvas.width - bgImg.width * scale) / 2;
                const y = (canvas.height - bgImg.height * scale) / 2;
                ctx.drawImage(bgImg, x, y, bgImg.width * scale, bgImg.height * scale);
            }
            ctx.restore();

            // ì•¡ì…˜ ê·¸ë¦¬ê¸°
            diaryData.actions.forEach(action => drawAction(ctx, action));

            ctx.restore();
        }

        function drawAction(targetCtx, action) {
            targetCtx.save();

            if (action.type === 'line' || action.type === 'eraser') {
                if (action.type === 'eraser') {
                    targetCtx.globalCompositeOperation = "destination-out";
                } else {
                    targetCtx.strokeStyle = action.color;
                    if (action.brush === 'normal') {
                        targetCtx.globalAlpha = 0.8;
                    } else if (action.brush === 'calligraphy') {
                        targetCtx.lineCap = 'butt';
                    } else if (action.brush === 'glow') {
                        targetCtx.lineCap = 'butt';
                        targetCtx.lineJoin = 'miter';
                        targetCtx.globalAlpha = 0.3;
                        targetCtx.shadowBlur = 10;
                        targetCtx.shadowColor = action.color;
                    }
                }

                targetCtx.lineWidth = action.size;
                targetCtx.lineCap = (action.brush === 'glow') ? 'butt' : 'round';
                targetCtx.lineJoin = 'round';
                targetCtx.beginPath();

                action.points.forEach((p, i) => {
                    if (i === 0) targetCtx.moveTo(p.x, p.y);
                    else targetCtx.lineTo(p.x, p.y);
                });

                targetCtx.stroke();
            } else if (action.type === 'sticker') {
                targetCtx.font = `${action.size}px Arial`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText(action.content, action.x, action.y);
            }

            targetCtx.restore();
        }

        // í„°ì¹˜ ì¢Œí‘œ ë³€í™˜
        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            const sx = touch.clientX - rect.left;
            const sy = touch.clientY - rect.top;

            const x = (sx - (canvas.width / 2 + panOffset.x)) / zoomLevel + canvas.width / 2;
            const y = (sy - (canvas.height / 2 + panOffset.y)) / zoomLevel + canvas.height / 2;

            return { x, y, sx, sy };
        }

        // í„°ì¹˜ ì´ë²¤íŠ¸
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const pos = getTouchPos(touch);
            lastTouchPos = { x: touch.clientX, y: touch.clientY };

            if (mode === 'pan') {
                isPanning = true;
            } else if (mode === 'sticker') {
                diaryData.actions.push({
                    type: 'sticker',
                    x: pos.x,
                    y: pos.y,
                    content: currentSticker,
                    size: activeSize * 4
                });
                render();
                scheduleSave();
            } else if (mode === 'eraser') {
                // ìŠ¤í‹°ì»¤ ì§€ìš°ê¸° ì²´í¬
                let deleted = false;
                for (let i = diaryData.actions.length - 1; i >= 0; i--) {
                    const a = diaryData.actions[i];
                    if (a.type === 'sticker') {
                        const dist = Math.sqrt((pos.x - a.x) ** 2 + (pos.y - a.y) ** 2);
                        if (dist < a.size / 2) {
                            diaryData.actions.splice(i, 1);
                            deleted = true;
                            render();
                            scheduleSave();
                            break;
                        }
                    }
                }
                if (!deleted) {
                    isDrawing = true;
                    diaryData.actions.push({
                        type: 'eraser',
                        brush: 'normal',
                        points: [pos],
                        color: '#fff',
                        size: activeSize * 2
                    });
                }
            } else {
                isDrawing = true;
                diaryData.actions.push({
                    type: 'line',
                    brush: brushType,
                    points: [pos],
                    color: activeColor,
                    size: activeSize
                });
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const pos = getTouchPos(touch);

            if (isPanning) {
                panOffset.x += touch.clientX - lastTouchPos.x;
                panOffset.y += touch.clientY - lastTouchPos.y;
                lastTouchPos = { x: touch.clientX, y: touch.clientY };
                render();
            } else if (isDrawing) {
                diaryData.actions[diaryData.actions.length - 1].points.push(pos);
                render();
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isDrawing = false;
            isPanning = false;
            scheduleSave();
        });

        // ë„êµ¬ ë²„íŠ¼ ì´ë²¤íŠ¸
        toolBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const newMode = btn.dataset.mode;
                setMode(newMode);

                if (newMode === 'sticker') {
                    stickerPanel.classList.add('active');
                }
            });
        });

        function setMode(m) {
            mode = m;
            toolBtns.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === m);
            });

            // ë¶“ ì¢…ë¥˜ëŠ” ê·¸ë¦¬ê¸° ëª¨ë“œì—ì„œë§Œ í‘œì‹œ
            document.getElementById('brush-types').style.display =
                (m === 'draw') ? 'flex' : 'none';
        }

        // ìƒ‰ìƒ ë²„íŠ¼ ì´ë²¤íŠ¸
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                activeColor = btn.dataset.color;
                colorBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                scheduleSave();
            });
        });

        // ë¶“ ì¢…ë¥˜ ë²„íŠ¼ ì´ë²¤íŠ¸
        brushTypeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                brushType = btn.dataset.brush;
                brushTypeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                scheduleSave();
            });
        });

        // êµµê¸° ìŠ¬ë¼ì´ë”
        sizeSlider.addEventListener('input', () => {
            activeSize = parseInt(sizeSlider.value);
            scheduleSave();
        });

        // ìŠ¤í‹°ì»¤ ì„ íƒ
        function selectSticker(emoji) {
            currentSticker = emoji;
            stickerPanel.classList.remove('active');
            setMode('sticker');
        }

        document.getElementById('btn-close-sticker').addEventListener('click', () => {
            stickerPanel.classList.remove('active');
        });

        // ë’¤ë¡œê°€ê¸°
        document.getElementById('btn-back').addEventListener('click', () => {
            // ëª¨ë°”ì¼ ìƒíƒœ ì—…ë°ì´íŠ¸
            const mobileState = JSON.parse(localStorage.getItem('mobileGameState') || '{}');
            mobileState.stage2Completed = true;
            localStorage.setItem('mobileGameState', JSON.stringify(mobileState));

            window.location.href = 'index.html?completed=2';
        });

        // ì·¨ì†Œ (Undo)
        document.getElementById('btn-undo').addEventListener('click', () => {
            if (diaryData.actions.length > 0) {
                diaryData.actions.pop();
                render();
                scheduleSave();
            }
        });

        // ì´ˆê¸°í™”
        document.getElementById('btn-clear').addEventListener('click', () => {
            showConfirm("ëª¨ë“  ê·¸ë¦¼ê³¼ ìŠ¤í‹°ì»¤ë¥¼ ì´ˆê¸°í™”í• ê¹Œìš”?", () => {
                diaryData.actions = [];
                render();
                scheduleSave();
            });
        });

        // ì»¨íŒ ëª¨ë‹¬
        let confirmCallback = null;

        function showConfirm(msg, onYes) {
            document.getElementById('confirm-msg').textContent = msg;
            confirmCallback = onYes;
            confirmOverlay.classList.add('active');
        }

        document.getElementById('confirm-yes').addEventListener('click', () => {
            if (confirmCallback) confirmCallback();
            confirmOverlay.classList.remove('active');
        });

        document.getElementById('confirm-no').addEventListener('click', () => {
            confirmOverlay.classList.remove('active');
        });

        // í™”ë©´ ë¦¬ì‚¬ì´ì¦ˆ
        window.addEventListener('resize', initCanvas);

        // ì‹œì‘
        init();
    </script>
</body>
</html>
