<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1단계: 기초 한자 - 마법천자문</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background-image: url('img/modal1.png');
            background-size: cover;
            background-position: center;
            position: relative;
        }

        .game-container::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
        }

        .game-content {
            position: relative;
            z-index: 1;
            width: 100%;
            max-width: 900px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
            color: white;
        }

        .game-header h1 {
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
        }

        .game-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 1.2rem;
        }

        .stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 20px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            max-width: 600px;
            margin: 0 auto;
        }

        .card {
            aspect-ratio: 3/4;
            cursor: pointer;
            perspective: 1000px;
            position: relative;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card.matched .card-inner {
            transform: rotateY(180deg);
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .card-front {
            background-image: url('img/card.png');
            background-size: cover;
            background-position: center;
        }

        .card-back {
            background: linear-gradient(145deg, #f5f5dc 0%, #e8e4c9 100%);
            transform: rotateY(180deg);
            border: 3px solid #8b4513;
            flex-direction: column;
            padding: 10px;
        }

        .card-back .hanja {
            font-size: 2.5rem;
            font-weight: bold;
            color: #2c1810;
        }

        .card-back .meaning {
            font-size: 1rem;
            color: #5a4a3a;
            margin-top: 5px;
        }

        .card.matched {
            pointer-events: none;
        }

        .card.matched .card-back {
            background: linear-gradient(145deg, #90EE90 0%, #7CCD7C 100%);
            border-color: #228B22;
        }

        @keyframes shake {
            0%, 100% { transform: rotateY(180deg) translateX(0); }
            25% { transform: rotateY(180deg) translateX(-5px); }
            75% { transform: rotateY(180deg) translateX(5px); }
        }

        .card.wrong .card-inner {
            animation: shake 0.3s ease-in-out;
        }

        /* Result Modal */
        .result-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .result-modal.active {
            display: flex;
        }

        .result-content {
            background: linear-gradient(145deg, #2a2a4a, #1a1a2e);
            border: 2px solid #ffd700;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            color: white;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        .result-content h2 {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #ffd700;
        }

        .result-stats {
            margin: 20px 0;
            font-size: 1.2rem;
            line-height: 2;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .result-btn {
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
        }

        .btn-retry {
            background: #4a4a6a;
            color: white;
        }

        .btn-retry:hover {
            background: #5a5a7a;
        }

        .btn-save {
            background: linear-gradient(145deg, #ffd700, #ffb700);
            color: #1a1a2e;
        }

        .btn-save:hover {
            background: linear-gradient(145deg, #ffdd33, #ffc733);
            transform: scale(1.05);
        }

        /* Timer warning */
        .timer.warning {
            color: #ff6b6b;
            animation: pulse 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-content">
            <div class="game-header">
                <h1>1단계: 기초 한자 매칭</h1>
                <div class="game-stats">
                    <div class="stat">시간: <span id="timer">60</span>초</div>
                    <div class="stat">매칭: <span id="matches">0</span>/4</div>
                    <div class="stat">시도: <span id="attempts">0</span></div>
                </div>
            </div>

            <div class="card-grid" id="cardGrid">
                <!-- Cards will be generated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div class="result-modal" id="resultModal">
        <div class="result-content">
            <h2 id="resultTitle">게임 완료!</h2>
            <div class="result-stats">
                <p>걸린 시간: <span id="resultTime">0</span>초</p>
                <p>시도 횟수: <span id="resultAttempts">0</span>회</p>
                <p>점수: <span id="resultScore">0</span>점</p>
            </div>
            <div class="result-buttons">
                <button class="result-btn btn-retry" onclick="restartGame()">다시하기</button>
                <button class="result-btn btn-save" onclick="finishGame()">기록 저장</button>
            </div>
        </div>
    </div>

    <script>
        // Hanja data for Stage 1 (Basic characters - numbers and fundamentals)
        const hanjaData = [
            { hanja: '一', reading: '일', meaning: '하나' },
            { hanja: '二', reading: '이', meaning: '둘' },
            { hanja: '三', reading: '삼', meaning: '셋' },
            { hanja: '四', reading: '사', meaning: '넷' },
            { hanja: '五', reading: '오', meaning: '다섯' },
            { hanja: '六', reading: '육', meaning: '여섯' },
            { hanja: '七', reading: '칠', meaning: '일곱' },
            { hanja: '八', reading: '팔', meaning: '여덟' },
            { hanja: '九', reading: '구', meaning: '아홉' },
            { hanja: '十', reading: '십', meaning: '열' },
            { hanja: '大', reading: '대', meaning: '크다' },
            { hanja: '小', reading: '소', meaning: '작다' }
        ];

        // Game state
        let gameState = {
            cards: [],
            flippedCards: [],
            matchedPairs: 0,
            attempts: 0,
            timeLeft: 60,
            timer: null,
            isLocked: false,
            gameStarted: false,
            startTime: null
        };

        const cardGrid = document.getElementById('cardGrid');
        const timerDisplay = document.getElementById('timer');
        const matchesDisplay = document.getElementById('matches');
        const attemptsDisplay = document.getElementById('attempts');
        const resultModal = document.getElementById('resultModal');

        // Initialize game
        function initGame() {
            // Reset state
            gameState = {
                cards: [],
                flippedCards: [],
                matchedPairs: 0,
                attempts: 0,
                timeLeft: 60,
                timer: null,
                isLocked: false,
                gameStarted: false,
                startTime: null
            };

            // Select 4 random hanja for matching (8 cards total)
            const shuffledHanja = [...hanjaData].sort(() => Math.random() - 0.5);
            const selectedHanja = shuffledHanja.slice(0, 4);

            // Create pairs: hanja cards and reading/meaning cards
            const cardPairs = [];
            selectedHanja.forEach((item, index) => {
                // Hanja card
                cardPairs.push({
                    id: index,
                    type: 'hanja',
                    content: item.hanja,
                    pairId: index
                });
                // Reading/Meaning card
                cardPairs.push({
                    id: index,
                    type: 'reading',
                    content: `${item.reading}\n(${item.meaning})`,
                    pairId: index
                });
            });

            // Shuffle cards
            gameState.cards = cardPairs.sort(() => Math.random() - 0.5);

            // Render cards
            renderCards();

            // Update display
            updateDisplay();
        }

        function renderCards() {
            cardGrid.innerHTML = '';

            gameState.cards.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.dataset.index = index;

                const isHanja = card.type === 'hanja';
                const displayContent = card.content.split('\n');

                cardElement.innerHTML = `
                    <div class="card-inner">
                        <div class="card-front"></div>
                        <div class="card-back">
                            <div class="hanja" style="font-size: ${isHanja ? '3rem' : '1.5rem'}">${displayContent[0]}</div>
                            ${displayContent[1] ? `<div class="meaning">${displayContent[1]}</div>` : ''}
                        </div>
                    </div>
                `;

                cardElement.addEventListener('click', () => flipCard(index));
                cardGrid.appendChild(cardElement);
            });
        }

        function flipCard(index) {
            if (gameState.isLocked) return;

            const card = gameState.cards[index];
            const cardElement = cardGrid.children[index];

            // Don't flip if already flipped or matched
            if (cardElement.classList.contains('flipped') ||
                cardElement.classList.contains('matched')) {
                return;
            }

            // Start timer on first flip
            if (!gameState.gameStarted) {
                startTimer();
                gameState.gameStarted = true;
                gameState.startTime = Date.now();
            }

            // Flip the card
            cardElement.classList.add('flipped');
            gameState.flippedCards.push({ index, card });

            // Check for match when 2 cards are flipped
            if (gameState.flippedCards.length === 2) {
                gameState.isLocked = true;
                gameState.attempts++;
                attemptsDisplay.textContent = gameState.attempts;

                checkMatch();
            }
        }

        function checkMatch() {
            const [first, second] = gameState.flippedCards;

            // Match if same pairId but different types
            const isMatch = first.card.pairId === second.card.pairId &&
                           first.card.type !== second.card.type;

            if (isMatch) {
                // Mark as matched
                cardGrid.children[first.index].classList.add('matched');
                cardGrid.children[second.index].classList.add('matched');

                gameState.matchedPairs++;
                matchesDisplay.textContent = gameState.matchedPairs;

                // Check for win
                if (gameState.matchedPairs === 4) {
                    setTimeout(showResult, 500);
                }

                gameState.flippedCards = [];
                gameState.isLocked = false;
            } else {
                // Show wrong animation
                cardGrid.children[first.index].classList.add('wrong');
                cardGrid.children[second.index].classList.add('wrong');

                // Flip back after delay
                setTimeout(() => {
                    cardGrid.children[first.index].classList.remove('flipped', 'wrong');
                    cardGrid.children[second.index].classList.remove('flipped', 'wrong');
                    gameState.flippedCards = [];
                    gameState.isLocked = false;
                }, 1000);
            }
        }

        function startTimer() {
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                timerDisplay.textContent = gameState.timeLeft;

                // Warning when time is low
                if (gameState.timeLeft <= 10) {
                    timerDisplay.parentElement.classList.add('warning');
                }

                // Time's up
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timer);
                    showResult(true);
                }
            }, 1000);
        }

        function updateDisplay() {
            timerDisplay.textContent = gameState.timeLeft;
            matchesDisplay.textContent = gameState.matchedPairs;
            attemptsDisplay.textContent = gameState.attempts;
            timerDisplay.parentElement.classList.remove('warning');
        }

        function showResult(timeUp = false) {
            clearInterval(gameState.timer);

            const elapsedTime = gameState.startTime ?
                Math.floor((Date.now() - gameState.startTime) / 1000) : 60;
            const score = calculateScore(elapsedTime, gameState.attempts, gameState.matchedPairs);

            document.getElementById('resultTitle').textContent =
                timeUp ? '시간 초과!' : '게임 완료!';
            document.getElementById('resultTime').textContent = elapsedTime;
            document.getElementById('resultAttempts').textContent = gameState.attempts;
            document.getElementById('resultScore').textContent = score;

            resultModal.classList.add('active');
        }

        function calculateScore(time, attempts, matches) {
            // Base score for matches
            let score = matches * 100;

            // Time bonus (more points for faster completion)
            score += Math.max(0, (60 - time) * 2);

            // Efficiency bonus (fewer attempts = better)
            const efficiency = matches > 0 ? matches / attempts : 0;
            score += Math.floor(efficiency * 50);

            return score;
        }

        function restartGame() {
            resultModal.classList.remove('active');
            initGame();
        }

        function finishGame() {
            // Save score to localStorage
            const score = parseInt(document.getElementById('resultScore').textContent);
            const userId = localStorage.getItem('edugame_current_user') || 'guest';

            const records = JSON.parse(localStorage.getItem('edugame_records') || '{}');
            if (!records[userId]) {
                records[userId] = { stage1: [] };
            }
            if (!records[userId].stage1) {
                records[userId].stage1 = [];
            }

            records[userId].stage1.push({
                score: score,
                time: parseInt(document.getElementById('resultTime').textContent),
                attempts: parseInt(document.getElementById('resultAttempts').textContent),
                date: new Date().toISOString()
            });

            localStorage.setItem('edugame_records', JSON.stringify(records));

            // Return to main game
            window.location.href = 'index.html';
        }

        // Start the game
        initGame();
    </script>
</body>
</html>
